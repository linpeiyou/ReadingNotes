## 1. 进程
### 1.1 进程模型
### 1.2 创建进程
### 1.3 进程的终止
### 1.4 进程的层次结构
### 1.5 进程的状态
### 1.6 进程的实现
### 1.7 多道程序设计模型


## 2. 线程
### 2.1 线程的使用
### 2.2 经典的线程模型
### 2.3 POSIX线程
### 2.4 在用户空间中实现线程
### 2.5 在内核中实现线程
### 2.6 混合实现
### 2.7 调度程序激活机制
### 2.8 弹出式线程
### 2.9 使单线程代码多线程化


## 3. 进程间通信（Inter Process Communication，IPC）

从问题出发：
1.一个进程如何把消息传递给另一个

2.确保两个或更多的进程在关键活动中不会出现交叉
如：在飞机订票系统中，两个进程为不同的客户试图争夺飞机上最后一个座位

3.正确的顺序（如果该顺序是有关联的话）
如：如果进程A产生数据而进程B打印数据，那么B在打印之前必须等待，直到A已经产生一些数据

这三个问题中的两个问题对于线程来说是同样适用的。
第一个问题对线程而言比较容易，因为同一个进程中的线程共享一个地址控件
另外两个问题同样适用于线程。同样的问题可用同样的方法解决。

### 3.1 竞争条件

定义：两个或多个进程读写某些共享数据，而最后的结果取决于进程的精确时序，称为竞争条件

在一些操作系统中，协作的进程可能共享一些彼此都能读写的公用存储区
这个公用存储区 可能在内存中（可能是在内核数据结构中），也可能是一个共享文件
（这里共享存储区的位置并不影响通信的本质及其带来的问题）

一个例子：
一个假脱机打印程序，当一个进程需要打印一个文件时，它将文件名放在一个特殊的假脱机目录下，另一个进程（打印机守护进程）则周期性地检查是否有文件需要打印，若有就打印并将该文件名从目录下删掉。
假设有两个共享变量：out，指向下一个要打印的文件；in，指向目录下一个空闲槽位
假设几乎在同一时刻，进程A和进程B都决定将一个文件排队打印
进程A读到in的值为7，将7存在一个局部变量next_free_slot中
**此时发生了一次时钟中断，CPU认为进程A已经运行了足够长的时间，决定切换到进程B**
进程B也读取in，同样得到值为7，于是将7存在B的局部变量next_free_slot中
这一时刻两个进程都认为下一个可用槽位是7
这样就导致了进程B永远得不到任何打印输出。

类似这样的情况，两个或多个进程读写某些共享数据，而最后的结果取决于进程的精确时序，称为竞争条件（race condition）

调试包含有竞争条件的程序是一件很头痛的事。大多数的测试运行结果都正确，但在极少数情况下会发生一些无法解释的奇怪现象

### 3.2 临界区

涉及共享内存、共享文件以及任何共享资源的情况都会引发竞争条件
要怎样避免竞争条件？

我们需要互斥，即以某种手段确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作
为实现互斥而选择适当的原语是设计操作系统的主要内容之一

进程在某些时候可能需要访问共享内存或共享文件，或执行另外一些会导致竞争的操作
我们把对共享内存进行访问的程序片段称作临界区域(critical region)或者临界区(critical section)
如果能够使得两个进程不可能同时处于临界区中，就能够避免竞争条件

要避免竞争条件，同时保证使用共享数据的并发进程能够正确高效地进行协作，要满足以下4个条件：
1.任何两个进程不能同时处于其临界区
2.不应对CPU的速度和数量做任何假设
3.临界区外运行的进程不得阻塞其他进程
4.不得使进程无限期等待进入临界区

### 3.3 忙等待的互斥

本节讨论几种实现互斥的方案
在这些方案中，当一个进程在临界区中更新共享内存时，其他进程不会进入其临界区，也不会带来任何麻烦

#### 1.屏蔽中断
在单处理器系统中，最简单的方法是使每个进程在刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前再打开中断
屏蔽中断后，时钟中断也被屏蔽，而CPU只有发生时钟中断或其他中断时才会进行进程切换
所以屏蔽中断后，CPU不会被切换到其他进程，它就可以检查和修改共享内存，不必担心其他进程的介入

这个方案并不好，把屏蔽中断的权利交给用户进程是不明智的：
- 若一个进程屏蔽中断后不再打开中断，整个系统可能会因此终止
- 如果系统是多处理器，则屏蔽中断仅仅对执行disable指令的那个CPU有效，其他CPU仍继续运行，并且可以访问共享内存

对内核来说，当它在更新变量或列表的几条指令期间将中断屏蔽是很方便的
当就绪进程队列之类的数据状态不一致时发生中断，将导致竞争条件
所以：屏蔽中断对于操作系统本身而言是一项很有用的技术，但对于用户进程则不是一项合适的通用互斥机制

现在的机器大部分是多核的，通过屏蔽中断来达到互斥的可能性越来越少了，在内核中也是

#### 2.锁变量
定义一个共享（锁）变量，其初始值为0
当一个进程想进入其临界区时，它先测试这把锁，
如果这把锁值为0，则该进程将其置为1并进入临界区
如果这把锁值为1，则该进程将等待直到其值变为0

但是这个做法和假脱机目录存在同样的问题
一个进程读出锁变量的值为0，在该进程将其值置为1之前，另外一个进程被调度运行，读到的值也为0
这样可能导致同时有两个进程进入临界区中

#### 3.严格轮换法
整型变量turn，初始值为0，用于记录轮到哪个进程进入临界区，并检查或更新共享内存
开始时
进程0检查turn，发现其值为0，于是进入临界区
进程1也发现其值为0，所以在一个等待循环中不停地测试turn，直到其值变为1
连续测试一个变量直到某个值出现为止，成为忙等待（busy waiting），这种方式浪费CPU时间，通常应该避免
```
// 进程0
while(TRUE) {
	while(turn != 0)
		critical_region();
	turn = 1;
	noncritical_region();
}

// 进程1
while(TRUE) {
	while(turn != 1)
		critical_region();
	turn = 0;
	noncritical_region();
}
```

只有在有理由认为等待时间是非常短的情形下，才使用忙等待。用于忙等待的锁，称为自旋锁(spin lock)

考虑下面情况：
进程0离开临界区时，它将turn的值置为1，以便允许进程1进入其临界区
-> 假设进程1很快便离开了临界区
-> 此时两个进程都处于临界区之外，turn的值又被设置为0
-> 现在进程0很快执行完其整个循环，它退出临界区，并将turn的值置为1
-> 此时，turn的值为1，两个进程都在其临界区外执行
-> 突然，进程0结束了非临界区的操作，进程0只有继续while循环，直到进程1把turn的值改为0
这说明，在一个进程比另一个慢了很多的情况下，轮流进入临界区并不是一个号方法

这种情况违反了前面的条件3：临界区外运行的进程不得阻塞其他进程

该方案要求两个进程严格地轮流进入它们的临界区。如假脱机文件，任何一个进程都不可能在一轮中打印两个文件
尽管该算法的确避免了所有的竞争条件，但它违反了条件3，所以不能作为一个很好的备选方案

#### 4.Peterson解法
完成互斥的Peterson解法：
```
#define FALSE 	0
#define TRUE	1
#define N 		2					/* 进程数量 */

int turn;							/* 现在轮到谁 */
int interested[N];					/* 所有值初始化为0（FALSE） */

void enter_region(int process)		/* 进程是0或1 */
{
	int other;						/* 其他进程号 */

	other = 1 - process;			/* 另一方进程 */
	interested[process] = TRUE;		/* 表明所感兴趣的 */
	turn = process;					/* 设置标志 */
	while(turn == process && interested[other] == TRUE)
		;							/* 空循环 */
}

void leave_region(int process)		/* 进程：谁离开 */
{
	interested[process] = FALSE;	/* 表示离开临界区 */
}
```
在进入其临界区之前，各个进程使用其进程号0或1作为参数来调用enter_region
该调用在需要时将使进程等待，直到能安全地进入临界区
在完成对共享变量的操作之后，进程将调用leave_region，表示操作已完成
其他的进程希望进入临界区，则现在就可以进入

该方案的工作流程：
一开始，没有任何进程处于临界区中，现在进程0调用enter_region
-> 进程0通过设置其数组元素和将turn置为0来标识它希望进入临界区，此时进程1不想进入临界区，所以enter_region很快返回，进入临界区成功
-> 如果进程1现在调用enter_region，进程1将在此处挂起直到interested[0]变成FALSE，该事件只有在进程0调用leave_region退出临界区时才会发生

两个进程几乎同时调用enter_region的情况：
进程0和进程1都将自己的进程号存入turn，但是只有后被保存进去的进程号才有效，前一个因被重写而丢失
假设进程1是后存入的，则turn为1，当两个进程都运行到while语句时，
进程0将循环0次并进入临界区，而进程1则不停地循环且不能进入临界区，直到进程0退出临界区为止

#### 5.TSL指令
现在来看需要硬件支持的一种方案
某些计算机中（特别是那些设计为多处理器的计算机），都有下面一条指令：
`TSL RX, LOCK`
称为测试并加锁（Test and Set Lock）
它将一个内存字lock读到寄存器RX中，然后在该内存地址上存一个非零值
**读字和写字操作保证是不可分割的，即该指令结束之前其他处理器均不允许访问该内存字**
**执行TSL指令的CPU将锁住内存总线，以禁止其他CPU在本指令结束之前访问内存**

这里区分一下**锁住内存总线**和**屏蔽中断**：
在某个处理器A上屏蔽中断对其他处理器根本没有任何影响
如果要让其他处理器远离内存直到处理器A完成的唯一方法就是锁住总线
这需要一个特殊的硬件设施（基本上，一根总线就可以确保总线由锁住它的处理器使用，而其他的处理器不能用）

为了使用TSL指令，要使用一个共享变量lock来协调对内存的访问。
当lock为0时，任何进程都可以使用TSL指令将其设置为1，并读写共享内存
当操作结束时，进程用一条普通的move指令将lock的值重新设置为0


使用TSL指令防止两个进程同时进入临界区：
第一条指令将lock的值复制到寄存器中，然后将lock设置为1
随后将寄存器中的值与0比较，如果非0则说明以前已被加锁，则程序回到开始并再次测试
经过一段时间后，该值变为0（当前处于临界区的进程退出临界区），于是过程返回，此时已加锁
要清除这个锁非常简单，程序只需将0存入lock即可，不需要特殊的同步指令
```
enter_region:
	TSL REGISTER, lock 		| 复制锁到临界区并将锁设为1
	CMP REGISTER, #0		| 锁是否为0
	JNE enter_region		| 若不是0，说明锁已被设置，所以循环
	RET 					| 返回，进入了临界区

leave_region:
	MOVE LOCK, #0 			| 将锁设为0
	RET 					| 返回
```

进程在进入临界区之前先调用enter_region，这将导致忙等待，直到锁空闲为止，随后它获得该锁并返回
在进程从临界区返回时它调用leave_region，这将把lock设置为0

一个可替代TSL的指令是XCHG，它原子性地交换了两个位置的内容，它本质上与TSL的解决办法一样
所有的Intel x86 CPU在底层同步中使用XCHG指令
```
enter_region:
	MOVE REGISTER, #1
	XCHG REGISTER, lock
	CMP  REGISTER, #0
	JNE  enter_region
	RET

leave_region:
	MOVE LOCK, #0
	RET
```


### 3.4 睡眠与唤醒
Peterson解法和TSL或XCHG解法都是正确的，但是他们都有忙等待的缺点
这些解法在本质上是这样的：当一个进程想进入临界区时，先检查是否允许进入，若不允许，则该进程将原地等待，直到允许为止

这种方法不仅浪费CPU时间，
还可能引起预想不到的结果：考虑一台计算机有两个进程，H优先级较高，L优先级较低
调度规则规定，只要H处于就绪态它就可以运行
某一时刻，L处于临界区中，此时H变到就绪态，准备运行
现在H开始忙等待，因为L还没离开临界区，所以H将永远忙等待下去
这种情况有时被称作优先级反转问题


几条进程间通信原语，它们将在无法进入临界区时阻塞，而不是忙等待
sleep是一个将引起调用进程阻塞的系统调用，即被挂起，直到另外一个进程将其唤醒
wakeup调用有一个参数，即要被唤醒的进程
另外一种方法是让sleep和wakeup各有一个参数，即有一个用于匹配sleep和wakeup的内存地址

#### 生产者消费者问题
两个进程共享一个公共的固定大小的缓冲区。其中一个是生产者，将信息放入缓冲区；另一个是消费者，从缓冲区中取出信息

当缓冲区已满，此时生产者还想向其中放入新的数据时，让生产者睡眠，等消费者从缓冲区取出数据时再唤醒它
当缓冲区为空，此时消费者想向缓冲区取出数据时，让消费者睡眠，等生产者向缓冲区放入数据时再唤醒它

```
#define N 100				/* 缓冲区中的槽数目 */
int count = 0;				/* 缓冲区中的数据项数目 */

void producer(void)
{
	int item;

	while(TRUE) {
		item = produce_item();
		if(count == N)
			sleep();
		insert_item(item);
		count = count + 1;
		if(count == 1)
			wakeup(consumer);
	}
}

void consumer(void)
{
	int item;

	while(TRUE) {
		if(count == 0)
			sleep();
		item = remove_item();
		count = count - 1;
		if(count == N - 1)
			wakeup(producer);
		consume_item(item);
	}
}
```
上面这段代码可能出现竞争条件的问题，因为对count的访问未加限制
考虑如下情况：
缓冲区为空，消费者执行到if(count == 0)，还未执行sleep()的时候，此时调度程序决定暂停消费者并启动运行生产者
-> 生产者向缓冲区中加入一个数据，此时count==1，于是生产者调用wakeup来唤醒消费者
-> 但是此时消费者并未睡眠，因此wakeup信号丢失
-> 当调度程序启动运行消费者的时候，执行sleep()，将导致生产者填满整个缓冲区，然后生产者和消费者都在睡眠状态

问题的实质在于发给一个未睡眠的进程的wakeup信号丢失了
一种快速的弥补方法是，加上一个唤醒等待位。
当一个wakeup信号发送给一个清醒的进程信号时，将该位置1
随后，当该进程要睡眠时，如果唤醒等待位为1，则将该位清除，而该进程仍然保持清醒

在这个例子中唤醒等待位能解决问题，但是在三个或更多的进程中，一个唤醒等待位就不够用了。
唤醒等待位没有从根本上解决问题

### 3.5 信号量（Semaphore）
Dijkstra在1965年提出的一种方法，它使用一个整形变量来累计唤醒次数，供以后使用，称为信号量(semaphore)
一个信号量可以为0（表示没有保存下来的唤醒操作）或者正值（表示有一个或多个唤醒操作）

两种操作：down和up（分别为一般化后的sleep和wakeup）
#### down操作
**对一信号量执行down操作，则是检查其值是否大于0。若值大于0，则将其减1（即用掉一个保存的唤醒信号）并继续**
**若该值为0，则进程将睡眠，而且此时down操作并未结束**
**检查数值、修改变量值以及可能发生的睡眠操作均作为一个单一的、不可分割的原子操作完成**
**保证一旦一个信号量操作开始，则在该操作完成或阻塞之前，其他进程不允许访问该信号量**

**这种原子性对于解决同步问题和避免竞争条件是绝对必要的**
**所谓原子操作，是指一组相关联的操作要么都执行，要么都不执行**

#### up操作
**up操作对信号量的值增1，如果一个或多个进程在该信号量上睡眠，无法完成一个先前的down操作，则由系统选择其中的一个（如随机挑选）并允许该进程完成它的down操作**
**于是，对一个有进程在其上睡眠的信号量执行一次up操作之后，该信号量的值仍旧是0，但是在其上睡眠的进程却少了一个**
**信号量的值增1和唤醒一个进程同样是不可分割的。不会有某个进程因进行up而阻塞，正如在前面的模型中不会有进程因执行wakeup而阻塞一样**

（这里的down和up即为P和V，荷兰语中，Proberen的意思是尝试，Verhogen的含义是增加）

#### 用信号量解决生产者-消费者问题
**用信号量解决丢失的wakeup问题，为确保信号量能正常工作，最重要的是采用一种不可分割的方式来实现它**
**通常是将up和down作为系统调用实现，而且操作系统只需要在执行以下操作时暂时屏蔽全部中断：测试信号量、更新信号量以及在需要时使某个进程睡眠**

**由于这些动作只需要几条指令，所以屏蔽中断不会带来什么副作用**
**如果使用多个CPU，则每个信号量应由一个锁变量进行保护。通过TSL或XCHG指令来确保同一时刻只有一个CPU在对信号量进行操作**

**使用TSL或XCHG指令来防止几个CPU同时访问一个信号量，这与生产者或消费者使用忙等待来等待对方腾出或填充缓冲区是完全不同的**
**信号量操作仅需几个毫秒，而生产者或消费者则可能需要任意长的时间**


我们通过两种不同的方式来使用信号量
1.信号量mutex用于互斥，它用于保证任一时刻只有一个进程读写缓冲区和相关的变量
2.信号量full和empty用与实现同步(synchronization)，它们保证某种时间的顺序发生或不发生
在本例中，它们保证当缓冲区满的时候生产者停止运行；当缓冲区空的时候消费者停止运行
```	
// 使用信号量的生产者-消费者问题
#define N 100 						/* 缓冲区中的槽数目 */
typedef int semaphore 				/* 信号量 */
semaphore mutex = 1; 				/* 控制对临界区的访问 */
semaphore empty = N;				/* 计数缓冲区的空槽数目 */
semaphore full = 0;					/* 计数缓冲区的满槽数目 */

void producer(void)
{
	int item;

	while(TRUE) {
		item = produce_item();
		down(&empty);				/* 将空槽数目减1 */
		down(&mutex);				/* 进入临界区 */
		insert_item(item);
		up(&mutex);					/* 离开临界区 */
		up(&full);					/* 将满槽的数目加1 */
	}
}

void consumer(void)
{
	int item;

	while(TRUE) {
		down(&full);				/* 将满槽的数目减1 */
		down(&mutex);				/* 进入临界区 */
		item = remove_item();
		up(&mutex);					/* 离开临界区 */
		up(&empty);					/* 将空槽的数目加1 */
		consume_item(item);
	}
}
```

### 3.6 互斥量
如果不需要信号量的计数能力，有时可以使用信号量的一个简化版本，称为互斥量（mutex），互斥量仅适用于管理共享资源或一小段代码
由于互斥量在实现时既容易又有效，所以互斥量在实现用户空间线程包时非常有用

互斥量是一个可以处于两态之一的变量：解锁和加锁
所以只需要一个二进制位来表示它，不过实际上经常使用一个整形量，0表示解锁，其他所有值表示加锁

当一个线程访问临界区时，调用mutex_lock
如果该互斥量当前是解锁的（临界区可用），此调用成功，调用线程可用自由进入该临界区
如果该互斥量已经加锁，调用线程被阻塞，直到在临界区中的线程完成并调用mutex_unlock
（如果多个线程被阻塞在该互斥量上，将随机选择一个线程并允许它获得锁）

由于互斥量非常简单，所以如果有可用的TSL或XCHG指令，可用很容易在用户空间中实现它们：
```
// mutex_lock和mutex_unlock的实现
mutex_lock:
	TSL  REGISTER, MUTEX 			| 将互斥信号量复制到寄存器，并将互斥信号量置为1
	CMP  REGISTER, #0
	JZE  ok							| 如果互斥信号量为0，它被解锁，所以返回
	CALL thread_yield				| 互斥信号量忙，调度另一个线程
	JMP  mutex_unlock 				| 稍后再试
ok: RET

mutex_unlock:
	MOVE MUTEX, #0 					| 将互斥信号量置为0
	RET
```

上面的enter_region代码段进入临界区失败时，它始终重复测试锁（忙等待）
**而mutex_lock在获取锁失败时，会调用thread_yield将CPU放弃给另一个线程，这样就不会忙等待，
在该线程下次运行时，它再一次对锁进行测试**




### 3.7 管程

### 3.8 消息传递

### 3.9 屏障


## 4. 调度
### 4.1 调度介绍
### 4.2 批处理系统中的调度
### 4.3 交互式系统中的调度
### 4.4 实时系统中的调度
### 4.5 策略和机制
### 4.6 线程调度


## 5. 经典的IPC问题
### 5.1 哲学家就餐问题
### 5.2 读者-写者问题

## 6. 有关进程和线程的研究

## 7. 小结









































