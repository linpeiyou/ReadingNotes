


## 3. 进程间通信（Inter Process Communication，IPC）

从问题出发：
1.一个进程如何把消息传递给另一个

2.确保两个或更多的进程在关键活动中不会出现交叉
如：在飞机订票系统中，两个进程为不同的客户试图争夺飞机上最后一个座位

3.正确的顺序（如果该顺序是有关联的话）
如：如果进程A产生数据而进程B打印数据，那么B在打印之前必须等待，直到A已经产生一些数据

这三个问题中的两个问题对于线程来说是同样适用的。
第一个问题对线程而言比较容易，因为同一个进程中的线程共享一个地址控件
另外两个问题同样适用于线程。同样的问题可用同样的方法解决。

### 3.1 竞争条件

定义：两个或多个进程读写某些共享数据，而最后的结果取决于进程的精确时序，称为竞争条件

在一些操作系统中，协作的进程可能共享一些彼此都能读写的公用存储区
这个公用存储区 可能在内存中（可能是在内核数据结构中），也可能是一个共享文件
（这里共享存储区的位置并不影响通信的本质及其带来的问题）

一个例子：
一个假脱机打印程序，当一个进程需要打印一个文件时，它将文件名放在一个特殊的假脱机目录下，另一个进程（打印机守护进程）则周期性地检查是否有文件需要打印，若有就打印并将该文件名从目录下删掉。
假设有两个共享变量：out，指向下一个要打印的文件；in，指向目录下一个空闲槽位
假设几乎在同一时刻，进程A和进程B都决定将一个文件排队打印
进程A读到in的值为7，将7存在一个局部变量next_free_slot中
**此时发生了一次时钟中断，CPU认为进程A已经运行了足够长的时间，决定切换到进程B**
进程B也读取in，同样得到值为7，于是将7存在B的局部变量next_free_slot中
这一时刻两个进程都认为下一个可用槽位是7
这样就导致了进程B永远得不到任何打印输出。

类似这样的情况，两个或多个进程读写某些共享数据，而最后的结果取决于进程的精确时序，称为竞争条件（race condition）

调试包含有竞争条件的程序是一件很头痛的事。大多数的测试运行结果都正确，但在极少数情况下会发生一些无法解释的奇怪现象

### 3.2 临界区

涉及共享内存、共享文件以及任何共享资源的情况都会引发竞争条件
要怎样避免竞争条件？

我们需要互斥，即以某种手段确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作
为实现互斥而选择适当的原语是设计操作系统的主要内容之一

进程在某些时候可能需要访问共享内存或共享文件，或执行另外一些会导致竞争的操作
我们把对共享内存进行访问的程序片段称作临界区域(critical region)或者临界区(critical section)
如果能够使得两个进程不可能同时处于临界区中，就能够避免竞争条件

要避免竞争条件，同时保证使用共享数据的并发进程能够正确高效地进行协作，要满足以下4个条件：
1.任何两个进程不能同时处于其临界区
2.不应对CPU的速度和数量做任何假设
3.临界区外运行的进程不得阻塞其他进程
4.不得使进程无限期等待进入临界区

### 3.3 忙等待的互斥

本节讨论几种实现互斥的方案
在这些方案中，当一个进程在临界区中更新共享内存时，其他进程不会进入其临界区，也不会带来任何麻烦

#### 1.屏蔽中断
在单处理器系统中，最简单的方法是使每个进程在刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前再打开中断
屏蔽中断后，时钟中断也被屏蔽，而CPU只有发生时钟中断或其他中断时才会进行进程切换
所以屏蔽中断后，CPU不会被切换到其他进程，它就可以检查和修改共享内存，不必担心其他进程的介入

这个方案并不好，把屏蔽中断的权利交给用户进程是不明智的：
- 若一个进程屏蔽中断后不再打开中断，整个系统可能会因此终止
- 如果系统是多处理器，则屏蔽中断仅仅对执行disable指令的那个CPU有效，其他CPU仍继续运行，并且可以访问共享内存

对内核来说，当它在更新变量或列表的几条指令期间将中断屏蔽是很方便的
当就绪进程队列之类的数据状态不一致时发生中断，将导致竞争条件
所以：屏蔽中断对于操作系统本身而言是一项很有用的技术，但对于用户进程则不是一项合适的通用互斥机制

现在的机器大部分是多核的，通过屏蔽中断来达到互斥的可能性越来越少了，在内核中也是

#### 2.锁变量
定义一个共享（锁）变量，其初始值为0
当一个进程想进入其临界区时，它先测试这把锁，
如果这把锁值为0，则该进程将其置为1并进入临界区
如果这把锁值为1，则该进程将等待直到其值变为0

但是这个做法和假脱机目录存在同样的问题
一个进程读出锁变量的值为0，在该进程将其值置为1之前，另外一个进程被调度运行，读到的值也为0
这样可能导致同时有两个进程进入临界区中

#### 3.严格轮换法
整型变量turn，初始值为0，用于记录轮到哪个进程进入临界区，并检查或更新共享内存
开始时
进程0检查turn，发现其值为0，于是进入临界区
进程1也发现其值为0，所以在一个等待循环中不停地测试turn，直到其值变为1
连续测试一个变量直到某个值出现为止，成为忙等待（busy waiting），这种方式浪费CPU时间，通常应该避免
```
// 进程0
while(TRUE) {
	while(turn != 0)
		critical_region();
	turn = 1;
	noncritical_region();
}

// 进程1
while(TRUE) {
	while(turn != 1)
		critical_region();
	turn = 0;
	noncritical_region();
}
```

只有在有理由认为等待时间是非常短的情形下，才使用忙等待。用于忙等待的锁，称为自旋锁(spin lock)

考虑下面情况：
进程0离开临界区时，它将turn的值置为1，以便允许进程1进入其临界区
-> 假设进程1很快便离开了临界区
-> 此时两个进程都处于临界区之外，turn的值又被设置为0
-> 现在进程0很快执行完其整个循环，它退出临界区，并将turn的值置为1
-> 此时，turn的值为1，两个进程都在其临界区外执行
-> 突然，进程0结束了非临界区的操作，进程0只有继续while循环，直到进程1把turn的值改为0
这说明，在一个进程比另一个慢了很多的情况下，轮流进入临界区并不是一个号方法

这种情况违反了前面的条件3：临界区外运行的进程不得阻塞其他进程

该方案要求两个进程严格地轮流进入它们的临界区。如假脱机文件，任何一个进程都不可能在一轮中打印两个文件
尽管该算法的确避免了所有的竞争条件，但它违反了条件3，所以不能作为一个很好的备选方案

#### 4.Peterson解法
完成互斥的Peterson解法：
```
#define FALSE 	0
#define TRUE	1
#define N 		2					/* 进程数量 */

int turn;							/* 现在轮到谁 */
int interested[N];					/* 所有值初始化为0（FALSE） */

void enter_region(int process)		/* 进程是0或1 */
{
	int other;						/* 其他进程号 */

	other = 1 - process;			/* 另一方进程 */
	interested[process] = TRUE;		/* 表明所感兴趣的 */
	turn = process;					/* 设置标志 */
	while(turn == process && interested[other] == TRUE)
		;							/* 空循环 */
}

void leave_region(int process)		/* 进程：谁离开 */
{
	interested[process] = FALSE;	/* 表示离开临界区 */
}
```
在进入其临界区之前，各个进程使用其进程号0或1作为参数来调用enter_region
该调用在需要时将使进程等待，直到能安全地进入临界区
在完成对共享变量的操作之后，进程将调用leave_region，表示操作已完成
其他的进程希望进入临界区，则现在就可以进入

该方案的工作流程：
一开始，没有任何进程处于临界区中，现在进程0调用enter_region
-> 进程0通过设置其数组元素和将turn置为0来标识它希望进入临界区，此时进程1不想进入临界区，所以enter_region很快返回，进入临界区成功
-> 如果进程1现在调用enter_region，进程1将在此处挂起直到interested[0]变成FALSE，该事件只有在进程0调用leave_region退出临界区时才会发生

两个进程几乎同时调用enter_region的情况：
进程0和进程1都将自己的进程号存入turn，但是只有后被保存进去的进程号才有效，前一个因被重写而丢失
假设进程1是后存入的，则turn为1，当两个进程都运行到while语句时，
进程0将循环0次并进入临界区，而进程1则不停地循环且不能进入临界区，直到进程0退出临界区为止

#### 5.TSL指令
现在来看需要硬件支持的一种方案
某些计算机中（特别是那些设计为多处理器的计算机），都有下面一条指令：
`TSL RX, LOCK`
称为测试并加锁（Test and Set Lock）
它将一个内存字lock读到寄存器RX中，然后在该内存地址上存一个非零值
**读字和写字操作保证是不可分割的，即该指令结束之前其他处理器均不允许访问该内存字**
**执行TSL指令的CPU将锁住内存总线，以禁止其他CPU在本指令结束之前访问内存**

这里区分一下**锁住内存总线**和**屏蔽中断**：
在某个处理器A上屏蔽中断对其他处理器根本没有任何影响
如果要让其他处理器远离内存直到处理器A完成的唯一方法就是锁住总线
这需要一个特殊的硬件设施（基本上，一根总线就可以确保总线由锁住它的处理器使用，而其他的处理器不能用）

为了使用TSL指令，要使用一个共享变量lock来协调对内存的访问。
当lock为0时，任何进程都可以使用TSL指令将其设置为1，并读写共享内存
当操作结束时，进程用一条普通的move指令将lock的值重新设置为0


使用TSL指令防止两个进程同时进入临界区：
第一条指令将lock的值复制到寄存器中，然后将lock设置为1
随后将寄存器中的值与0比较，如果非0则说明以前已被加锁，则程序回到开始并再次测试
经过一段时间后，该值变为0（当前处于临界区的进程退出临界区），于是过程返回，此时已加锁
要清除这个锁非常简单，程序只需将0存入lock即可，不需要特殊的同步指令
```
enter_region:
	TSL REGISTER, lock 		| 复制锁到临界区并将锁设为1
	CMP REGISTER, #0		| 锁是否为0
	JNE enter_region		| 若不是0，说明锁已被设置，所以循环
	RET 					| 返回，进入了临界区

leave_region:
	MOVE LOCK, #0 			| 将锁设为0
	RET 					| 返回
```

进程在进入临界区之前先调用enter_region，这将导致忙等待，直到锁空闲为止，随后它获得该锁并返回
在进程从临界区返回时它调用leave_region，这将把lock设置为0

一个可替代TSL的指令是XCHG，它原子性地交换了两个位置的内容，它本质上与TSL的解决办法一样
所有的Intel x86 CPU在底层同步中使用XCHG指令
```
enter_region:
	MOVE REGISTER, #1
	XCHG REGISTER, lock
	CMP  REGISTER, #0
	JNE  enter_region
	RET

leave_region:
	MOVE LOCK, #0
	RET
```


### 3.4 睡眠与唤醒
Peterson解法和TSL或XCHG解法都是正确的，但是他们都有忙等待的缺点
这些解法在本质上是这样的：当一个进程想进入临界区时，先检查是否允许进入，若不允许，则该进程将原地等待，直到允许为止

这种方法不仅浪费CPU时间，
还可能引起预想不到的结果：考虑一台计算机有两个进程，H优先级较高，L优先级较低
调度规则规定，只要H处于就绪态它就可以运行
某一时刻，L处于临界区中，此时H变到就绪态，准备运行
现在H开始忙等待，因为L还没离开临界区，所以H将永远忙等待下去
这种情况有时被称作优先级反转问题


几条进程间通信原语，它们将在无法进入临界区时阻塞，而不是忙等待
sleep是一个将引起调用进程阻塞的系统调用，即被挂起，直到另外一个进程将其唤醒
wakeup调用有一个参数，即要被唤醒的进程
另外一种方法是让sleep和wakeup各有一个参数，即有一个用于匹配sleep和wakeup的内存地址

#### 生产者消费者问题
两个进程共享一个公共的固定大小的缓冲区。其中一个是生产者，将信息放入缓冲区；另一个是消费者，从缓冲区中取出信息

当缓冲区已满，此时生产者还想向其中放入新的数据时，让生产者睡眠，等消费者从缓冲区取出数据时再唤醒它
当缓冲区为空，此时消费者想向缓冲区取出数据时，让消费者睡眠，等生产者向缓冲区放入数据时再唤醒它

```
#define N 100				/* 缓冲区中的槽数目 */
int count = 0;				/* 缓冲区中的数据项数目 */

void producer(void)
{
	int item;

	while(TRUE) {
		item = produce_item();
		if(count == N)
			sleep();
		insert_item(item);
		count = count + 1;
		if(count == 1)
			wakeup(consumer);
	}
}

void consumer(void)
{
	int item;

	while(TRUE) {
		if(count == 0)
			sleep();
		item = remove_item();
		count = count - 1;
		if(count == N - 1)
			wakeup(producer);
		consume_item(item);
	}
}
```
上面这段代码可能出现竞争条件的问题，因为对count的访问未加限制
考虑如下情况：
缓冲区为空，消费者执行到if(count == 0)，还未执行sleep()的时候，此时调度程序决定暂停消费者并启动运行生产者
-> 生产者向缓冲区中加入一个数据，此时count==1，于是生产者调用wakeup来唤醒消费者
-> 但是此时消费者并未睡眠，因此wakeup信号丢失
-> 当调度程序启动运行消费者的时候，执行sleep()，将导致生产者填满整个缓冲区，然后生产者和消费者都在睡眠状态

问题的实质在于发给一个未睡眠的进程的wakeup信号丢失了
一种快速的弥补方法是，加上一个唤醒等待位。
当一个wakeup信号发送给一个清醒的进程信号时，将该位置1
随后，当该进程要睡眠时，如果唤醒等待位为1，则将该位清除，而该进程仍然保持清醒

在这个例子中唤醒等待位能解决问题，但是在三个或更多的进程中，一个唤醒等待位就不够用了。
唤醒等待位没有从根本上解决问题

### 3.5 信号量（Semaphore）
Dijkstra在1965年提出的一种方法，它使用一个整形变量来累计唤醒次数，供以后使用，称为信号量(semaphore)
一个信号量可以为0（表示没有保存下来的唤醒操作）或者正值（表示有一个或多个唤醒操作）

两种操作：down和up（分别为一般化后的sleep和wakeup）
#### down操作
**对一信号量执行down操作，则是检查其值是否大于0。若值大于0，则将其减1（即用掉一个保存的唤醒信号）并继续**
**若该值为0，则进程将睡眠，而且此时down操作并未结束**
**检查数值、修改变量值以及可能发生的睡眠操作均作为一个单一的、不可分割的原子操作完成**
**保证一旦一个信号量操作开始，则在该操作完成或阻塞之前，其他进程不允许访问该信号量**

**这种原子性对于解决同步问题和避免竞争条件是绝对必要的**
**所谓原子操作，是指一组相关联的操作要么都执行，要么都不执行**

#### up操作
**up操作对信号量的值增1，如果一个或多个进程在该信号量上睡眠，无法完成一个先前的down操作，则由系统选择其中的一个（如随机挑选）并允许该进程完成它的down操作**
**于是，对一个有进程在其上睡眠的信号量执行一次up操作之后，该信号量的值仍旧是0，但是在其上睡眠的进程却少了一个**
**信号量的值增1和唤醒一个进程同样是不可分割的。不会有某个进程因进行up而阻塞，正如在前面的模型中不会有进程因执行wakeup而阻塞一样**

（这里的down和up即为P和V，荷兰语中，Proberen的意思是尝试，Verhogen的含义是增加）

#### 用信号量解决生产者-消费者问题
**用信号量解决丢失的wakeup问题，为确保信号量能正常工作，最重要的是采用一种不可分割的方式来实现它**
**通常是将up和down作为系统调用实现，而且操作系统只需要在执行以下操作时暂时屏蔽全部中断：测试信号量、更新信号量以及在需要时使某个进程睡眠**

**由于这些动作只需要几条指令，所以屏蔽中断不会带来什么副作用**
**如果使用多个CPU，则每个信号量应由一个锁变量进行保护。通过TSL或XCHG指令来确保同一时刻只有一个CPU在对信号量进行操作**

**使用TSL或XCHG指令来防止几个CPU同时访问一个信号量，这与生产者或消费者使用忙等待来等待对方腾出或填充缓冲区是完全不同的**
**信号量操作仅需几个毫秒，而生产者或消费者则可能需要任意长的时间**


我们通过两种不同的方式来使用信号量
1.信号量mutex用于互斥，它用于保证任一时刻只有一个进程读写缓冲区和相关的变量
2.信号量full和empty用与实现同步(synchronization)，它们保证某种时间的顺序发生或不发生
在本例中，它们保证当缓冲区满的时候生产者停止运行；当缓冲区空的时候消费者停止运行
```	
// 使用信号量的生产者-消费者问题
#define N 100 						/* 缓冲区中的槽数目 */
typedef int semaphore 				/* 信号量 */
semaphore mutex = 1; 				/* 控制对临界区的访问 */
semaphore empty = N;				/* 计数缓冲区的空槽数目 */
semaphore full = 0;					/* 计数缓冲区的满槽数目 */

void producer(void)
{
	int item;

	while(TRUE) {
		item = produce_item();
		down(&empty);				/* 将空槽数目减1 */
		down(&mutex);				/* 进入临界区 */
		insert_item(item);
		up(&mutex);					/* 离开临界区 */
		up(&full);					/* 将满槽的数目加1 */
	}
}

void consumer(void)
{
	int item;

	while(TRUE) {
		down(&full);				/* 将满槽的数目减1 */
		down(&mutex);				/* 进入临界区 */
		item = remove_item();
		up(&mutex);					/* 离开临界区 */
		up(&empty);					/* 将空槽的数目加1 */
		consume_item(item);
	}
}
```

### 3.6 互斥量
如果不需要信号量的计数能力，有时可以使用信号量的一个简化版本，称为互斥量（mutex），互斥量仅适用于管理共享资源或一小段代码
由于互斥量在实现时既容易又有效，所以互斥量在实现用户空间线程包时非常有用

互斥量是一个可以处于两态之一的变量：解锁和加锁
所以只需要一个二进制位来表示它，不过实际上经常使用一个整型量，0表示解锁，其他所有值表示加锁

当一个线程访问临界区时，调用mutex_lock
如果该互斥量当前是解锁的（临界区可用），此调用成功，调用线程可用自由进入该临界区
如果该互斥量已经加锁，调用线程被阻塞，直到在临界区中的线程完成并调用mutex_unlock
（如果多个线程被阻塞在该互斥量上，将随机选择一个线程并允许它获得锁）

由于互斥量非常简单，所以如果有可用的TSL或XCHG指令，可用很容易在用户空间中实现它们：
```
// mutex_lock和mutex_unlock的实现
mutex_lock:
	TSL  REGISTER, MUTEX 			| 将互斥信号量复制到寄存器，并将互斥信号量置为1
	CMP  REGISTER, #0
	JZE  ok							| 如果互斥信号量为0，它被解锁，所以返回
	CALL thread_yield				| 互斥信号量忙，调度另一个线程
	JMP  mutex_unlock 				| 稍后再试
ok: RET

mutex_unlock:
	MOVE MUTEX, #0 					| 将互斥信号量置为0
	RET
```

上面的enter_region代码段进入临界区失败时，它始终重复测试锁（忙等待）
**而mutex_lock在获取锁失败时，会调用thread_yield将CPU放弃给另一个线程，这样就不会忙等待，
在该线程下次运行时，它再一次对锁进行测试**

由于thread_yield只是在用户空间中对线程调度程序的一个调用，所以它的运行非常快捷
这样，mutex_lock和mutex_unlock都不需要任何内核调用
通过使用这些过程，用户线程完全可以实现在用户空间中的同步，这些过程仅仅需要少量的指令


多个进程是如何共享变量的？两种方案：
1.有些共享数据，如信号量，可以存放在内核中，并且只能通过系统调用来访问
2.多数现代操作系统（包括UNIX和Windows）提供一种方法，让进程与其他进程共享其部分地址空间。在这种方法中，缓冲区和其他数据结构可以共享。在最坏的情况下，如果没有可共享的途径，则可以使用共享文件。


如果两个或多个进程共享其全部或大部分地址空间，那么进程和线程的差别就变得模糊起来
但是无论怎样，两者的差别还是有的：
**共享一个公共地址空间的两个进程仍旧有各自的打开文件、报警定时器以及其他一些单个进程的特性**
**而在单个进程里的线程，则共享进程的全部特性**
**另外，共享一个公共地址空间的多个进程绝不会拥有用户级线程的效率，这一点是不容置疑的，因为内核还同其管理密切相关**

#### pthread中的互斥
**一些互斥量相关的pthread调用：**
pthread_mutex_init		：创建一个互斥量
pthread_mutex_destroy	：撤销一个已存在的互斥量
pthread_mutex_lock 		：获得一个锁或阻塞
pthread_mutex_trylock	：获得一个锁或失败
pthread_mutex_unlock	：释放一个锁

除互斥量之外，pthread提供了另一种同步机制：**条件变量**
互斥量在允许或阻塞对临界区的访问上是很有用的，条件变量则允许线程由于一些未达到的条件而阻塞
绝大部分情况下这两种方法是一起使用的


例子：在生产者-消费者问题中，如果生产者发现缓冲区已满，它不得不阻塞起来直到有一个空槽可以使用
生产者使用互斥量可以进行原子性检查，不受其他线程干扰。但是当发现缓冲区已满，生产者需要一种方法来阻塞自己并在以后被唤醒，这就是条件变量做的事


**一些与条件变量相关的pthread调用**
pthread_cond_init		：创建一个条件变量
pthread_cond_destroy	：撤销一个条件变量
pthread_cond_wait		：阻塞以等待一个信号
pthread_cond_signal		：向另外一个线程发信号来唤醒它
pthread_cond_broadcast	：向多个线程发信号来让它们全部唤醒

条件变量与互斥量经常一起使用
**这种模式用于让一个线程锁住一个互斥量，然后当它不能获得它期待的结果时等待一个条件变量**
**然后另一个线程会向它发信号，使它可以继续执行，pthread_cond_wait原子性地调用并解锁它持有的互斥量。**
由于这个原因，互斥量是参数之一

**注意，条件变量（不像信号量）不会存在内存中。如果将一个信号量传递给一个没有线程在等待的条件变量，那么这个信号就会丢失。要小心使用避免丢失信号**

Demo（缓冲区大小为1的生产者-消费者问题）：
```
// 使用线程、互斥量、条件变量解决生产者-消费者问题
#include <stdio.h>
#include <pthread.h>
#define MAX 1000000000				/* 需要生产的数量 */
pthread_mutex_t the_mutex;
pthread_cond_t condc, condp;
int buffer = 0;						/* 生产者消费者使用的缓冲区 */

void *producer(void *ptr)
{
	int i;
	for(i = 1;i <= MAX; ++i)
	{
		pthread_mutex_lock(&the_mutex);
		while(buffer != 0) {
			pthread_cond_wait(&condp, &the_mutex);
		}
		buffer = i;
		pthread_cond_signal(&condc);
		pthread_mutex_unlock(&the_mutex);
	}
}

void *consumer(void *ptr)
{
	int i;
	for(i = 1; i <= MAX; ++i)
	{
		pthread_mutex_lock(&the_mutex);
		while(buffer == 0) {
			pthread_cond_wait(&condc, &the_mutex);
		}
		buffer = 0;
		pthread_cond_signal(&condp);
		pthread_mutex_unlock(&the_mutex);
	}
}

int main(int argc, char **argv)
{
	pthread_t pro, con;
	pthread_mutex_init(&the_mutex, 0);
	pthread_cond_init(&condc, 0);
	pthread_cond_init(&condp, 0);
	pthread_create(&pro, 0, producer, 0);
	pthread_create(&con, 0, consumer, 0);
	pthread_join(pro, 0);
	pthread_join(con, 0);
	pthread_cond_destroy(&condc);
	pthread_cond_destroy(&condp);
	pthread_mutex_destroy(&the_mutex);
}
```


### 3.7 管程

使用信号量或互斥量的时候，如果代码顺序写错，很容易就造成了竞争条件、死锁这样的严重问题。

为了更易于编写正确的程序，Brinch Hansen和Hoare提出了一种高级同步原语，称为管程（monitor，也称为监视器）
一个管程是一个由过程、变量以及数据结构等组成的一个集合，它们组成一个特殊的模块或软件包
进程可以在任何需要的时候调用管程中的过长，但它们不能在管程之外声明的过程中直接访问管程内的数据结构

```
// 用一种抽象的、类Pascal语言描述的管程
// 这里不能使用C语言，因为管程是语言概念而C语言并不支持它

monitor example
	integer i;
	condition c;

	procedure producer():
	...
	end;

	procedure consumer():
	...
	end;
end monitor;
```

**管程有一个很重要的特性，即任一时刻管程中只能有一个活跃进程，这一特性使管程能有效地完成互斥**

管程是编程语言的组成部分，编译器知道它们的特殊性，因此可以采用与其他过程调用不同的方法来处理对管程的调用
典型的处理方法是：当一个进程调用管程过程时，该过程中的前几条指令将检查在管程中是否有其他的活跃进程。
如果有，调用进程将被挂起，直到另外一个进程离开管程将其唤醒；如果没有，则该调用进程可以进入。

进入管程时的互斥由编译器负责，与我们手动实现相比出错的可能性小很多。
写管程的人无需关心编译器如何实现互斥，只需要把临界区转换成管程过程即可

从上面来看，管程提供了一种实现互斥的简便途径
但是我们还需要一种方法，使得进程在无法继续运行时被阻塞（如生产者在发现缓冲区满的时候该如何阻塞？）
**解决办法是引入条件变量，以及相关的两个操作：wait和signal**

当一个管程发现无法继续运行时（如生产者发现缓冲区满），它会在某个条件变量上（如full）执行wait操作
该操作导致调用进程自身阻塞，并将一个之前等在管程之外的进程调入管程
其他的进程（如消费者），可以通过对正在等待的一个条件变量执行signal操作，唤醒正在睡眠的进程

要避免管程中同时有两个活跃进程的话，signal操作执行完之后该怎么办
Hoare建议让新唤醒的进程运行，而挂起另外一个进程
Brinch Hansen建议执行signal的进程必须立即退出管程，signal只能作为管程过程的最后一条语句

尽管类Pascal是一种想象的语言，但还是有一些真正的编程语言支持管程，不过它们不一定是Hoare和Brinch Hansen所设计的模型
其中一种语言的Java，它支持用户级线程，还允许将方法（过程）划分为类
只要将关键词synchronized加入到方法声明中，Java保证一旦某个线程执行该方法，就不允许其他线程执行该对象中的任何synchronized方法
```
public class ProducerConsumer {
	static final int N = 100;			// 缓冲区大小
	static Producer p = new Producer();	// 生产者线程
	static Consumer c = new Consumer();	// 消费者线程
	static Monitor mon = new Monitor();	// 管程

	public static void main(String args[]) {
		p.start();
		c.start();
	}

	static class Monitor {
		private int[] buffer = new int[N];
		private int count = 0;	// 计数器
		private int lo = 0;		// 索引
		private int hi = 0;		// 索引

		public synchronized void insert(int val) {
			if(count == N)
				goToSleep();
			buffer[hi] = val;
			hi = (hi + 1) % N;
			++count;
			if(count == 1)
				notify();	// 如果消费者在休眠，将其唤醒
		}

		public synchronized void remove() {
			if(count == 0)
				goToSleep();
			val = buffer[lo];
			lo = (lo + 1) % N;
			--count;
			if(count == N - 1)
				notify();	// 如果生产者在休眠，将其唤醒
			return val;
		}
	}

	static class Producer extends Thread {
		pulbic void run() {
			while(true) {
				int item = produceItem();
				mon.insert(item);
			}
		}
		private int void produceItem() {...}	// 实际生产
	}

	static class Consumer extends Thread {
		pulbic void run() {
			while(true) {
				int item = mon.remove();
				consumeItem(item);
			}
		}
		private int void consumeItem() {...}	// 实际消费
	}
}
```

Java中的同步方法与其他的经典管程有本质差别：Java没有内嵌的条件变量
反之，Java提供了两个过程：wait和notify，它们与sleep和wakeup等价，不过，当它们在同步方法中使用时，它们不受竞争条件约束


管程的缺点：
管程是一个编程语言概念，编译器必须要识别管程并用某种方式对互斥做出安排。
比如C、Pascal以及多数其他语言都没有管程，所以指望这些编译器遵守互斥规则是不合理的。


与管程和信号量有关的另一个问题：
如果一个分布式系统具有多个CPU，并且每个CPU拥有自己的私有内存，它们通过一个局域网相连，那么这些原语将失效
信号量太低级了；而管程在少数几种编程语言之外又无法使用。而且这些原语均未提供机器间信息交换的方法，所以需要其他办法解决

### 3.8 消息传递
上面提到的其他办法就是消息传递（message passing）
这种进程间通信的方法是使用两条原语send和receive，它们像信号量而不像管程，是系统调用而不是语言成分

#### 1.消息传递系统的设计要点
**消息传递系统面临着许多信号量和管程所未涉及的问题和设计难点，特别是位于网络上不同机器上的通信进程的情况**
例如：消息有可能被网络丢失
为了防止消息丢失，发送方和接收方可以达成如下一致：
一旦接收到消息，接收方马上回送一条特殊的确认（acknowledgement）消息
如果发送方在一段时间间隔内未收到确认，则重发消息

如果消息被正确接收，而发送给发送者的确认消息丢失。发送者将重发消息，这样接受者将受到两次相同的消息
对于接受者来说，如何区分新消息 和 重发的老消息
通常采用在每条原始消息中嵌入一个连续的序号来解决这个问题
如果接受者收到一条信息，它具有与前面一条消息一样的序号，就知道这条消息是重复的

消息系统还需要解决**进程命名**的问题，在send和receive调用中所指定的进程必须是没有二义性的
**身份认证（authentication）**也是一个问题。比如客户机怎么知道它是在与一个真正的文件服务器通信，而不是与一个冒充者通信？

对于发送者和接收者在同一台机器上的情况，也存在若干设计问题。其中一个设计问题就是**性能问题**。
将消息从一个进程复制到另一个进程通常比信号量操作和进入管程要慢
为了使信息传递变得高效，人们已经做了许多工作
例如，Cheriton（1984）建议限制信息的大小，使其能装入机器的寄存器中，然后使用寄存器进行信息传递

#### 2.用消息传递解决生产者-消费者问题
用消息传递来解决生产者-消费者问题的一种解法：
前提：假设所有的消息都有相同的大小，并且在尚未接收到发出的消息时，由操作系统自动进行缓冲
```	
#define N 100						/* 缓冲区中的槽数目 */

void producer(void)
{
	int item;
	message m;						/* 消息缓冲区 */
	while(TRUE)
	{
		item = produce_item();		/* 产生放入缓冲区的一些数据 */
		receive(consumer, &m);		/* 等待消费者发送空缓冲区 */
		build_message(&m, item);	/* 建立一个待发送的消息 */
		send(consumer, &m);			/* 发送数据项给消费者 */
	}
}

void consumer(void)
{
	int item, i;
	message m;
	for(i = 0; i < N; ++i)
		send(producer, &m);			/* 发送N个空缓冲区 */
	while(TRUE)
	{
		receive(producer, &m);		/* 接收包含数据项的消息 */
		item = extract_item(&m);	/* 将数据项从消息中提取出来 */
		send(producer, &m);			/* 将空缓冲区发回生产者 */
		consume_item(item);			/* 处理数据项 */
	}
}
```
在该解决方案中共使用N条消息，类似于一块共享内存缓冲区中的N个槽
消费者首先将N条空消息发送给生产者
当生产者向消费者传递一个数据项时，它通过receive(consumer, &m)取走一条空消息并通过build_message 填充内容后发送回去
通过这种方式，系统中的总消息数保持不变，所以消息都可以存放在事先确定数量的内存中


消息传递方式可以有许多变体。我们首先介绍如何对消息进行编址。
**一种方法是为每个进程分配一个唯一的地址，让消息按进程的地址编址**
**另一种方法是引入一种新的数据结构，称作信箱**

信箱是一个用来对一定数量的消息进行缓冲的地方，信箱中消息数量的设置方法也有多种，典型的方法是在信箱创建时确定消息的数量
当使用信箱时，在send和receive调用中的地址参数就是信箱的地址，而不是进程的地址
当一个进程试图向一个满的信箱发消息时，它将被挂起，直到信箱内有消息被取走，从而为新消息腾出空间

对于生产者-消费者问题，生产者和消费者均应创建足够容纳N条消息的信箱
生产者向消费者信箱发送包含实际数据的消息，消费者则向生产者信箱发送空的消息
当使用信箱时，缓冲机制的作用是很清楚的：目标信箱容纳那些已被发送但尚未被目标进程接收的信息

使用信箱的另一种极端方法是彻底取消缓冲
采用这种方法时，如果先执行send，则发送进程被阻塞，直到receive发生。在执行receive时，消息可以直接从发送者复制到接收者，不用任何中间缓冲。
类似地，如果先执行receive，则接收者会被阻塞，直到send发生。

这种方案常被称为会合，与带有缓冲的消息方案相比，该方案实现起来更容易一些，但是降低了灵活性，因为发送者和接收者一定要以步步紧接的方式运行

通常在并行程序设计系统中使用消息传递。例如，一个著名的消息传递系统是消息传递接口（Message-Passing Interface, MPI），它广泛应用在科学计算中。

### 3.9 屏障
最后一个同步机制是准备用于进程组而不是用于双进程的生产者-消费者类似情形的
有些应用中划分了若干阶段，并且规定除非有所的进程都就绪准备着手下一个阶段，否则任何进程都不能进入下一个阶段
可以通过在每个阶段的结尾安置屏障（barrier）来实现这种行为
当一个进程到达屏障时，它就被屏障阻拦，直到所有进程都到达该屏障为止




